---
layout: post
title: MIP* = RE ตอนที่ 1
subtitle:
date: 2020-04-19
categories:
tags:
---

<div id="toc"></div>

ถ้าจะมีอะไรที่ทำให้ผมออกจาก hiatus การเขียนบล็อกได้ก็ต้องเป็นเรื่องใหญ่พอสมควร เรื่องนั้นคือบทพิสูจน์ [MIP*=RE](https://arxiv.org/abs/2001.04383) ที่นักสารสนเทศควอนตัมหลายคนไม่คิดว่าชั่วชีวิตนี้จะได้เห็นข้อสรุป (เช่น[คนนี้](https://www.scottaaronson.com/blog/?p=4512#comment-1828159)และ[คนนี้](https://twitter.com/jfitzsimons/status/1216908264396378112)) ผลงานนี้มาได้ตรงจังหวะ ไม่กี่วันหลังจากผมกลับมาจากงานประชุม [QIP2020](http://www.szpclab.com/qip2020) ที่เชินเจิ้น ซึ่ง Anand Natarajan ได้พูดเรื่อง [NEEXT $\subset$ MIP*](https://arxiv.org/abs/1904.05870) และทิ้งท้ายด้วยคำถามว่า "ทำไมเราจะต้องหยุดที่ NEEXT ล่ะ?"

<center>
<img src="/assets/img/2020/NEEXT_in_MIP_future.jpg" style="width: 500px;"/>
</center>

ทำไมผมถึงตื่นเต้นกับงานชิ้นนี้? สมมติว่าอยู่ดีๆมีคนคนหนึ่งมาเคาะประตูแล้วบอกว่าเขาเป็นพระเจ้าผู้ทรงมีอำนาจไม่สิ้นสุด จะมีวิธีอะไรที่จะทดสอบเขาโดยไม่ต้องอาศัยความเชื่อได้? วิธึหนึ่งคือการให้แก้ปัญหายากๆ ที่เราสามารถเช็คคำตอบได้ในเวลาสั้นๆ อย่างปัญหา [NP-complete](https://en.wikipedia.org/wiki/NP-completeness) แต่ถ้าเรายังคลางแคลงใจเนื่องจากยังไม่มีการพิสูจน์ [P $\neq$ NP](https://en.wikipedia.org/wiki/P_versus_NP_problem) ปัญหา NP-complete จริงๆแล้วอาจจะง่ายก็ได้ เราอาจจะอยากถามปัญหาที่ตัวตนที่มีขีดจำกัด (finite being) อย่างมนุษย์ไม่มีทางตอบได้ไม่ว่าจะใช้เวลานานเท่าไรก็ตามเช่นคำถามว่าเครื่อง Turing จะหยุดหรือไม่ (ปัญหา [halting](https://en.wikipedia.org/wiki/Halting_problem)) แต่เราจะเช็คคำตอบได้ยังไงล่ะ? MIP* = RE บอกเราว่า**ถ้ามีเทพเจ้าสององค์ที่ไม่สื่อสารกันแต่สร้างเอนแทงเกิลเมนต์ปริมาณอนันต์ระหว่างกันได้ เทพเจ้าจะ convince เราได้อย่างรวดเร็วว่าเครื่องจักร Turing จะหยุด** [^1]

เพื่อป้องกันการเข้าใจผิดต้องบอกไว้ก่อนว่า**คอมพิวเตอร์ควอนตัมแก้ปัญหา halting ไม่ได้** เพราะเครื่องจักร Turing จำลองคอมพิวเตอร์ควอนตัมได้ (ถึงแม้จะต้องใช้เวลานาน) และเครื่องจักร Turing แก้ปัญหา halting ไม่ได้ ผลงานใหม่นี้ไม่ได้หมายความว่าคอมพิวเตอร์หนึ่งเครื่องกับคอมพิวเตอร์ควอนตัมสองเครื่องแก้ปัญหา halting ได้ เพราะคอมพิวเตอร์ควอนตัมไม่มีเอนแทงเกิลเมนต์ปริมาณอนันต์ ถึงแม้เอนแทงเกลเมนต์ปริมาณมหาศาลเข้าใกล้อนันต์ก็ใช้แทนกันไม่ได้ (นี่คือจุดสำคัญที่ปฏิเสธ [Connes' embedding conjecture](https://en.wikipedia.org/wiki/Connes_embedding_problem)) งานชิ้นนี้จึงยังไม่สามารถถูกนำไปใช้ได้โดยตรง

<!--งานชิ้นนี้เผยความสัมพันธ์ที่ไม่คาดคิดระหว่างทฤษฎีควอนตัมและ[ทฤษฎีบทความไม่สมบูรณ์ของ Gödel](https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems) ซึ่งเทียบเท่ากับปัญหา halting. ทั้งสองเป็นเรื่องที่ผมสนใจก่อนจะมาเรียนฟิสิกส์ (เหตุผลที่ทำให้ผมเรียนฟิสิกส์คือปรัชญา :smiley:) เพราะทั้งคู่ดูเหมือนจะกล่าวถึงขอบเขตจำกัดของสิ่งที่เรารู้ได้ ([ความไม่แน่นอนของ Heisenberg](https://en.wikipedia.org/wiki/Uncertainty_principle))
 แต่ MIP*=RE เป็นอีกครั้งที่การค้นพบในสารสนเทศควอนตัมพลิกความคาดหมายว่าทฤษฎีควอนตัมไม่ใช่ข้อจำกัด แต่เป็นความเป็นไปได้ใหม่-->

ในช่วง social distancing นี้ ผมอยากจะหาคำตอบด้วยการเขียนบล็อกว่าเอนแทงเกิลเมนต์ช่วยหาคำตอบของปัญหา halting ได้อย่างไร โดยไม่ได้กะจะเข้าใจบทพิสูจน์ MIP*=RE แต่สำหรับผู้อ่านผมจะต้องอธิบายปัญหา halting และเอนแทงเกิลเมนต์ก่อน ก่อนที่จะไปทำความเข้าใจ[เกมควอนตัมในฐานะ interactive proof](https://arxiv.org/abs/quant-ph/0404076) (ทำไมผมถึงพลาดเปเปอร์เจ๋งๆนี้จากปี 2004 ไปได้)  

# เครื่องจักร Turing

Alan Turing (1912-1954) ขณะที่กำลังศึกษาระดับ undergraduate ที่ Cambridge ก็พูดถึงคณิตศาสตร์ของคอมพิวเตอร์ ในสมัยนั้นเมื่อยังไม่มีคอมพิวเตอร์แบบในปัจจุบัน ความหมายเดิมของคอมพิวเตอร์คือผู้คำนวณที่ทำตามกระบวนการที่กำหนดไว้แล้วโดยไม่ต้องใช้ความคิดสร้างสรรค์ (คุ้นๆไหม?) ซึ่งกลายเป็นโมเดลของเครื่องจักร Turing (Turing machine) มีหน่วยความจำเป็น bit string แทนแผ่นกระดาษซึ่งทำหน้าที่รับ input และเขียนการคำนวณลงไปได้ จะเขียนอะไรก็ขึ้นอยู่กับชุดคำสั่งและสิ่งที่เขียนอยู่บนหน่วยความจำไว้ก่อนหน้า คอมพิวเตอร์สามารถอ่านหน่วยความจำได้ทีละช่องและถ้าจะเปลี่ยนไปยังช่องไกลๆต้องเคลื่อนที่ผ่านไปทีละช่องๆ นั่นก็คือมันต้องใช้เวลาในการเข้าถึงหน่วยความจำขนาดใหญ่ (คุณสมบัติซึ่งถูกใช้ในการพิสูจน์ "NP-completeness ของปัญหา 3SAT") นี่คือเครื่องจักร Turing เครื่องจักร Turing ไม่ใช่โมเดลของคอมพิวเตอร์จริงๆ แต่เป็นไอเดียทางทฤษฎี [^6] บางคนอาจจะนึกว่ามันต้องเป็นฮาร์ดแวร์แต่มันเป็นตัวแก้ปัญหาจึงจะคิดว่ามันเป็นซอฟต์แวร์หรือโปรแกรมก็ได้ และในที่สุดแล้วทุกอย่างเกี่ยวกับเครื่องจักร Turing สามารถเข้ารหัสเป็น bit string ได้ จึงคิดว่ามันเป็น input ก็ได้เช่นกัน นี่เป็นไอเดียที่ธรรมดามากสำหรับคนยุคนี้ว่าทุกอย่างที่จำลองในคอมพิวเตอร์ได้ก็แค่การคำนวณบน bit string แต่มันไม่ธรรมดาในสมัยนั้น

<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/E3keLeMwfHY?controls=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>

มีโมเดลในการคำนวณอื่นที่ถูกคิดค้นขึ้นมาในเวลาใกล้เคียงกันโดยเฉพาะ Lambda calculus ของ Alonzo Church Turing จึงถือโอกาสทำงานในระดับ graduate กับ Church ที่ Princeton แต่ปรากฎว่าโมเดลเหล่านี้มีพลังในการคำนวณเท่ากัน(ซึ่งเดี๋ยวก็จะได้เห็นว่าสำหรับจุดประสงค์ของโพสท์นี้แล้วจริงๆเราไม่จำเป็นจะต้องรู้กลไกการทำงานของเครื่องจักร Turing เลย แต่นั่นคือประเด็น ถึงแม้ว่าหลายๆอย่างท้ายที่สุดแล้วจะไม่ขึ้นกับทุกตัวอักษรของนิยามแต่ก็ต้องนิยามถึงจะทำการวิเคราะห์ทางคณิตศาสตร์ได้ โดยเฉพาะถ้าสนใจ computational complexity ต่อ) จึงได้ถือกำเนิดธีสิส (Thesis) ของ Church-Turing (ซึ่ง Stephen Kleene เป็นคนเรียก (1952)) ที่ว่าทุกๆอย่างที่คำนวณได้สามารถคำนวณได้ด้วยเครื่องจักร Turing [^7] คำถามก็คือธีสิสนี้ตั้งใจจะมีความหมายแบบไหนกันแน่ มันนิยาม "การคำนวณ" ด้วยเครื่องจักร Turing? หรือมันบอกว่าโมเดลการคำนวณที่เป็นไปได้ตามกฏของธรรมชาติไม่สามารถเอาชนะเครื่องจักร Turing ได้? ถ้าเข้าใจตามแบบหลัง จากความรู้ทั้งหมดที่มีอยู่(รวมทั้งควอนตัมคอมพิวเตอร์)ดูเหมือนว่าธีสิสของ Church-Turing จะเป็นจริง

ในเปเปอร์ปี 1936 Turing พิสูจน์สองอย่าง หนึ่งว่ามีเครื่องจักรของเขาที่อเนกประสงค์ (universal) คือเราไม่จำเป็นต้องสร้างคอมพิวเตอร์แบบหนึ่งเพื่อทำงาน อีกแบบเพื่อฟังเพลง อีกแบบเพื่อเล่นเกม ไอเดียคือการประมวลผลข้อมูลขึ้นอยู่กับกระบวนการเท่านั้นและไม่ขึ้นกับลักษณะทางกายภาพ จะเป็นเครื่องจักรกล สิ่งมีชีวิต ปรากฎการณ์ทางธรรมชาติ กาแล็กซี ก็เป็นคอมพิวเตอร์ได้ถ้ามันมีศักยภาพพอที่จะให้เราเข้ารหัสทำการคำนวณได้ พิสูจน์อย่างที่สองคือมีปัญหาที่เครื่องจักร Turing แก้ไม่ได้ และสิ่งที่เราอยากจะเสนอ (ซึ่งเป็นที่รู้กันทั่วไปในวิทยาศาสตร์คอมพิวเตอร์) คือทฤษฎีบทความไม่สมบูรณ์ของ Gödel เป็นจริงก็เพราะมีปัญหาที่แก้ไม่ได้บนเครื่องจักร Turing นั่นคือเราสามารถพิสูจน์ทฤษฎีบทความไม่สมบูรณ์ของ Gödel ได้ด้วยทฤษฎีคอมพิวเตอร์

## เราหยุดแล้ว แต่เรายังไม่หยุด

เครื่องจักร Turing ที่จะมีประโยชน์มากคือเครื่องจักร H ที่ตัดสินได้ว่าเมื่อเครื่องจักร Turing ได้รับ input หนึ่งๆเข้าไปจะรันไปโดยไม่มีวันหยุดหรือหยุดและให้คำตอบออกมา ถ้ามีเครื่องจักรนี้ก็จะช่วยในการแก้ปัญหาคณิตศาสตร์ได้อย่างมหาศาล เช่นถ้าจะพิสูจน์ข้อสันนิษฐานของ Goldbach“ทุกจำนวนคู่มากกว่า 2 เป็นผลบวกของสองจำนวนเฉพาะ” ก็แค่เอาเครื่องจักร Turing G ที่ตรวจสอบข้อสันนิษฐานนี้กับจำนวนคู่ทีละตัวๆ แล้วถาม H ว่า G จะหยุดไหม (เข้ารหัสโปรแกรม G เป็น bit string ป้อนให้ H เขียนแทนด้วย H(G)) ถ้าไม่หยุด ข้อสันนิษฐานของ Goldbach ก็เป็นจริง ปัญหาอื่นๆที่ต้องเช็คคุณสมบัติอะไรบางอย่างกับทุกๆสมาชิกก็จะแก้ได้โดยวิธีเดียวกัน

แต่ Turing เข้าใจได้ว่าไม่มีโปรแกรมที่จะแก้ปัญหานี้ได้ ทำไมน่ะเหรอ? อย่างที่บอกว่าเราสามารถป้อนเครื่องจักร Turing หนึ่ง เรียกว่า M ให้กับอีกเครื่องจักร Turing หนึ่งได้ โดยเฉพาะเราสามารถป้อน M ให้กับ M เองได้

M(M(M(…)))

คราวนี้นิยาม H’ ให้ H’(M) รันไปตลอดกาลถ้า M(M) หยุด และ H’(M) หยุดถ้า M(M) รันไปตลอดกาล แล้วก็ป้อน H’ ให้ตัวมันเอง ก็จะได้ว่า H’(H’) ทั้งหยุดทั้งรันไปตลอดกาลในเวลาเดียวกัน เป็นข้อขัดแย้งซึ่งบอกว่าเราไม่สามารถมี H (และ H’) ได้ตั้งแต่แรกแล้ว นี่คือ Halting problem

แน่นอนว่าจะใช้ปัญหาที่แก้ไม่ได้เกี่ยวกับเครื่องจักร Turing ปัญหาไหนในการพิสูจน์ก็ได้ และจริงๆแล้วทฤษฎี computability มีผลกระทบต่อคณิตศาสตร์สาขาอื่นๆเพราะมีหลายปัญหาที่คนอยากแต่พบว่าแก้ไม่ได้ในทำนองเดียวกันถึงแม้ว่าดูจะไม่มีอะไรที่ “ตลอดกาล” ในปัญหาเหมือน halting problem เช่นใน group theory, เราสามารถกำหนด group ได้ด้วย generators และความสัมพันธ์ระหว่าง generators (relations) สมาชิกของ group อาจจะเขียนในรูปของ generators ได้หลายแบบ (เรียกว่า “คำ” (word)) แต่มี finitely presented group (มี finite generators และ finite relations) ที่ปัญหาว่าคำสองคำแทนสมาชิกตัวเดียวกันหรือไม่ไม่สามารถแก้ได้ (ทฤษฎีบท Novikov-Boone) อีกตัวอย่างใน quantum information เร็วๆนี้คือปัญหาว่าระบบควอนตัมมี “spectral gap” -- ช่องว่างระหว่างระดับพลังงานที่ต่ำที่สุดกับระดับถัดขึ้นมา -- ใน thermodynamic limit หรือไม่ถูกแสดงว่าแก้ไม่ได้ในกรณีทั่วไป (จริงๆแล้วที่บอกไปไม่ใช่ปัญหาที่เขาพิสูจน์ว่าแก้ไม่ได้ซะทีเดียว ปัญหาของเขามีเงื่อนไขมากกว่านี้)

# ทฤษฎีบทของ Gödel

สำหรับคนที่ไม่ชอบเรื่องยุ่งยาก มันจะดีไม่น้อยถ้าเราสามารถค้นพบทุกความจริงได้ด้วยเซ็ตของ “ความจริงพื้นฐาน” ที่เล็กกว่าเซ็ตของความจริงทั้งหมด ในคณิตศาสตร์หมายความว่าเราต้องการความจริง (“axiom”) ที่นิยามด้วยกระบวนการที่สามารถปฏิบัติตามเป็นขั้นๆได้ (ไม่ใช่ตั้งทุกๆความจริงให้เป็น axioms ทั้งที่ไม่รู้ด้วยซ้ำว่าอะไรคือความจริงบ้าง) [^2] ที่สามารถนำไปใช้พิสูจน์ทุกความจริงได้เมื่อมีกฎในการพิสูจน์ (อย่างการอุปนัย) เช่น เรามี Peano axioms ของระบบจำนวนเต็ม หรือ axioms ของ ZFC set theory

เราจะรู้ได้อย่างไรว่า axioms เหล่านี้เป็น axioms ของระบบในความเป็นจริง ระบบในความเป็นจริงจะต้องไม่มีข้อขัดแย้งในตัวมันเอง (consistent) (ความขัดแย้งคือมีประพจน์ P ที่สามารถพิสูจน์ได้ทั้งว่าเป็นจริงและเป็นเท็จ (P และ not P))

Gödel พิสูจน์ทฤษฎีบทความสมบูรณ์ (completeness theorem) ที่กล่าวว่า ถ้า axiomatic system A [^3] มีความขัดแย้งในตัวมันเอง เราจะสามารถหามันได้ใน axioms หรือกลับกัน ถ้า เราไม่สามารถหาข้อขัดแย้งจาก axioms ได้ ทุกๆ realization ที่มาจาก axioms นั้นก็จะไม่มีข้อขัดแย้ง

แต่ Gödel (1931) ก็ดันพิสูจน์ทฤษฎีบทความไม่สมบูรณ์ (incompleteness theorem) ซึ่งมีสองส่วน เราเชื่อว่าทุกๆประพจน์ใน A ถ้าไม่เป็นจริงก็เป็นเท็จ และเราอาจจะหวังด้วยว่าเราสามารถพิสูจน์มันได้ด้วย axioms (สมบัติที่เรียกว่าความสมบูรณ์ (completeness) [^4]) แต่ Gödel บอกว่าความสมบูรณ์ต้องแลกมาด้วย unsoundness ซึ่งแปลว่าสิ่งที่พิสูจน์ได้อาจจะไม่เป็นจริง (พูดอีกแบบคือไม่มี A ที่สามารถพิสูจน์ทุกๆและเฉพาะประพจน์ที่เป็นจริงได้) ซึ่งเราไม่ต้องการในคณิตศาสตร์แน่ๆ อีกอย่างหนึ่งทีเราหวังว่าจะทำได้คือพิสูจน์ว่า A ไม่มีความขัดแย้งจาก axioms ของ A เองได้ (ต่างกับทฤษฎีบทความสมบูรณ์ที่บอกว่าพิสูจน์ว่า A มีความขัดแย้งจาก axioms ได้) แต่ Gödel ก็บอกอีกว่า A ที่พิสูจน์ความไม่ขัดแย้งของตัวมันเองได้มีแต่ A ที่มีความขัดแย้งในตัวมันเอง

สิ่งที่ Gödel ทำเพื่อพิสูจน์ทฤษฎีบทความไม่สมบูรณ์ส่วนแรกคือเขียนประพจน์ (“ประโยค Gödel”) G=“ประพจน์นี้ไม่สามารถพิสูจน์ใน A ได้” ใน A (ในบทพิสูจน์ของ Gödel A คือ axioms ใน Principia Mathematica ที่ใช้เกือบ 400 หน้าในการพิสูจน์ว่า 1+1=2 ของ Russell และ Whitehead ซึ่งซับซ้อนพอที่จะเขียนประพจน์นี้ได้) นี่คือส่วนที่ยาว แต่เมื่อเขียนได้แล้วคราวนี้เราก็สมมติว่า A สมบูรณ์ ถ้าพิสูจน์ G ได้ G ก็จะพิสูจน์ได้และพิสูจน์ไม่ได้ในเวลาเดียวกัน (มีความขัดแย้ง ซึ่ง implies unsoundness [^5]) ถ้าพิสูจน์ not G ““ประพจน์นี้ไม่สามารถพิสูจน์ใน A ได้” สามารถพิสูจน์ใน A ได้” ได้ ถ้า not G ไม่เป็นจริง A ก็จะ unsound ในขณะที่ถ้า not G เป็นจริง A ก็จะพิสูจน์ว่ามันพิสูจน์ G ได้ ถ้ามันพิสูจน์ได้จริงก็วนกลับไปเคสแรก ถ้ามันพิสูจน์ไม่ได้ก็ unsound เพราะมันพิสูจน์ “มันพิสูจน์ G” ที่ไม่เป็นจริงได้

---

เราจะพิสูจน์โดยการหาข้อขัดแย้ง (proof by contradiction) เริ่มจากสมมติว่าทฤษฎีบทความไม่สมบูรณ์ส่วนแรกไม่เป็นจริง และจะพิสูจน์ว่าเราแก้ halting problem ได้ เราจึงต้องพูดถึงทุกอย่างใน axiomatic system A แต่สิ่งที่ทำให้ง่ายในคราวนี้คือเราไม่ต้องสร้างประโยค Gödel แล้ว (self-reference เกิดไปแล้วในบทพิสูจน์ว่า halting problem แก้ไม่ได้ด้านบน) ประพจน์เกี่ยวกับการหยุดของโปรแกรมก็เป็นแค่ประพจน์เกี่ยวกับ bit string ซึ่งสามารถ express ได้ใน A ที่เข้าใจระบบจำนวนเต็ม เนื่องจาก A สมบูรณ์ ถ้าไม่พิสูจน์ได้ว่าโปรแกรมหนึ่งๆรันตลอดกาลก็ต้องพิสูจน์ได้ว่ามันหยุด สิ่งที่เราต้องทำก็คือเสิร์ชหาบทพิสูจน์นั้น เมื่อหาเจอแล้ว เนื่องจาก A sound สิ่งที่ A พิสูจน์จะต้องเป็นจริง A จึงแก้ halting problem ได้ แต่เรารู้แล้วว่ามันเป็นปัญหาที่แก้ไม่ได้จึงไม่มี A ที่ทำได้ดังที่กล่าวมา

คราวนี้ลองจินตนาการบทพิสูจน์ด้านบนว่า halting problem แก้ไม่ได้ในเวอร์ชัน “โปรแกรมที่เชื่อบางอย่างเกี่ยวกับตัวมันเอง” สมมติ axiomatic system A ซึ่งเข้าใจประพจน์อีกครั้ง และนิยามให้ H’(M) รันไปตลอดกาลถ้าพิสูจน์ได้ว่า M(M) หยุด และ H’(M) หยุดถ้าพิสูจน์ได้ว่า M(M) รันไปตลอดกาล จะเกิดอะไรขึ้นกับ H’(H’)? ถ้า A พิสูจน์ได้ว่า H’(H’) หยุด H’(H’) จะรันตลอดกาล และถ้าพิสูจน์ได้ว่า H’(H’) รันตลอดกาล H’(H’) จะหยุด แต่ H’(H’) ไม่จำเป็นจะต้องทั้งหยุดทั้งรันตลอดกาลในเวลาเดียวกันเพราะ

โปรแกรมที่หลอกตัวเอง: ถ้า A มีความขัดแย้งในตัวมันเองก็จะ unsound ดังนั้นมันจึงไม่มีปัญหาที่จะพิสูจน์สิ่งที่เป็นเท็จได้ถึงแม้จะเห็นความจริงอยู่ต่อหน้าก็ตาม จึงไม่สามารถสรุปอะไรได้

โปรแกรมที่ไม่เข้าใจตัวเอง: ถ้า A ไม่มีความขัดแย้งในตัวมันเอง มันจะไม่สามารถพิสูจน์ว่า H’(H’) รันไปตลอดกาลได้ เพราะถ้าพิสูจน์ได้ H’(H’) ก็จะหยุดเป็นตัวพิสูจน์ว่า H’(H’) หยุด H’(H’) จึงต้องรันไปตลอดกาล แต่ A ต้องไม่รู้ว่ามันไม่มีความขัดแย้งในตัวมันเองเพราะหาก A พิสูจน์ได้เมื่อไรว่ามันไม่มีความขัดแย้งในตัวมันเองก็เท่ากับพิสูจน์ได้ว่า H'(H’) ต้องรันตลอดกาล ทำให้มันต้องหยุดและเจอกับความขัดแย้งในตัวมันเอง ซึ่งเป็นไปไม่ได้เพราะเราสมมติตั้งแต่ต้นว่ามันไม่มีความขัดแย้งในตัวมันเอง axiomatic system ที่ไม่ความขัดแย้งในตัวเองจึงไม่สามารถพิสูจน์ได้ว่ามันไม่ขัดแย้งในตัวเอง

ทฤษฎีบทความไม่สมบูรณ์ของ Gödel ทั้งสองส่วนจึงพิสูจน์ได้ด้วยไอเดียของ Turing

# ทฤษฎีบทของ Rosser

แต่ทฤษฎีบทความไม่สมบูรณ์ของ Gödel ที่ผมมักได้ยินไม่มี unsoundness แต่เป็น “axiomatic system ที่สมบูรณ์ต้องมีความขัดแย้งในตัวมันเอง” แทน ซึ่ง strong กว่าทฤษฎีบทข้างต้นเพราะความขัดแย้งในตัวเอง implies unsoundness ปรากฎว่านี่ไม่ใช่ทฤษฎีบทที่ Gödel พิสูจน์แต่เป็น John Barkey Rosser (1907-1989) ในปี 1936 ปีเดียวกับที่ Turing พูดถึงเครื่องจักร Turing โดยเขียนประพจน์

R = “มีบทหักล้างของประพจน์นี้ที่สั้นกว่าทุกๆบทพิสูจน์ของประพจน์นี้ใน A”

ถ้าพิสูจน์ R ได้ก็จะหาบทหักล้าง (พิสูจน์ not R) ได้เพียงแค่เสิร์ช string ใน A ที่สั้นกว่าบทพิสูจน์ของ R ถ้าเจอก็มีความขัดแย้งใน A ถ้าไม่เจอก็จะเป็นบทพิสูจน์ของ not R เหมือนกัน(“สั้นกว่า”จึงเป็นจุดสำคัญ) ในทางกลับกันน่าสนใจว่าการพิสูจน์ not R ได้ให้ผลที่ mirror การพิสูจน์ R ได้เป๊ะๆ: “มีบทพิสูจน์ของประพจน์นี้ที่สั้นกว่าทุกๆบทหักล้างของประพจน์นี้ใน A” และนำไปสู่ความขัดแย้งด้วยเหตุผลเดียวกัน

ทฤษฎีบทของ Rosser ก็พิสูจน์โดยไม่ต้องสร้าง R ใน axiomatic system ได้! กำหนดปัญหาเรียกว่า Q: โปรแกรมจะ output 0 หรือ 1 หรือรันไปตลอดกาลเมื่อให้ input หนึ่งๆกับมัน? สมมติว่ามีโปรแกรม R ที่แก้ปัญหานี้ได้นิยาม R’ ให้ R’(M) output 0 ถ้า M(M) output 1, R’(M) output 1 ถ้า M(M) output 0, และสุดท้าย R’(M) หยุดและ output อะไรก็ได้ถ้า M(M) ไม่หยุด ไม่มีโปรแกรม R’ (และ R) ที่ทำอย่างนี้ได้

เนื่องจาก A สมบูรณ์ ถ้าพิสูจน์ไม่ได้ว่า M(M) output 0 ก็ต้องหักล้างได้ เราก็เสิร์ชหาบทพิสูจน์หรือบทหักล้าง ถึงแม้ A จะไม่มีความขัดแย้งในตัวมันเองแต่มันอาจจะ unsound ซึ่งอาจเห็นเป็นปัญหาแต่จริงๆแล้วไม่เป็นเพราะถ้า M(M) หยุด ความไม่ขัดแย้งในตัวเองของ A จะบังคับให้ A ตอบ output ที่ถูกต้องมิฉะนั้น output ของ M(M) จะเป็นบทพิสูจน์หรือหักล้างที่ขัดแย้งกับสิ่งที่ A เชื่อ และเกิด M(M) รันไปตลอดกาล A อยากจะทำอะไรก็เรื่องของมัน สรุปแล้ว: ตอบ 0 เมื่อพิสูจน์ได้และตอบ 1 เมื่อหักล้างได้ว่า M(M) output 0 ก็จะแก้ปัญหา Q ได้ แต่เรารู้แล้วว่ามันเป็นปัญหาที่แก้ไม่ได้จึงไม่มี A ที่ทำได้ดังที่กล่าวมา

# Penrose's *The Emperor's New Mind*



[^1]: ยอมรับว่าวิธีนี้ไม่จะเวิร์คถ้าเทพเจ้าทรงสัพพัญญู (omniscience) ด้วย คือรู้ได้ว่าเทพอีกองค์ทำอะไรโดยไม่ต้องสื่อสารกัน
