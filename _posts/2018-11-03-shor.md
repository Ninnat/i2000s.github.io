---
layout: post
title: อัลกอริธึมของชอร์
subtitle: ส่วนที่เป็นคลาสสิคัล, ส่วนที่เป็นควอนตัม, ข้อควรระวัง, และ รหัสลับหลังควอนตัม (post-quantum)
date: 2018-11-04
categories:
  - Quantum Information
tags:

---

อัลกอริธึมแยกตัวประกอบเป็นแอปปลิเคชันของคอมพิวเตอร์ควอนตัมที่สำคัญที่สุดหรือเปล่า? ผมว่าไม่ ผมคิดว่าการจำลองระบบควอนตัมจะเป็นแอปปลิเคชันที่ส่งผลกระทบต่อวิทยาศาสตร์และสังคมมากที่สุด แต่การแยกตัวประกอบและทำลายระบบความปลอดภัย RSA เป็นเรื่องที่ถูกถามบ่อยที่สุดก็เลยอยากจะเขียนเอาไว้อ้างถึง (มี[บล็อก](https://khunpanya.wordpress.com/2016/07/31/shors-algorithm/)ของคุณปัญญาอีกบล็อกที่เขียนเรื่องอัลกอริธึมนี้)

ก่อนอื่นเลย อัลกอริธึมแยกตัวประกอบของชอร์เป็นอัลกอริธึมหาคาบ (period finding) ของฟังก์ชันประเภทหนึ่ง ดังนั้นเราต้องมาเข้าใจกันก่อนว่าปัญหาการทำลายระบบ RSA และการแยกตัวประกอบลดรูปไปเป็นการหาคาบได้อย่างไร ซึ่งความเข้าใจส่วนนี้ไม่เกี่ยวกับควอนตัมเลย เป็นทฤษฎีจำนวนล้วนๆ ตอนก่อนจะมาเรียนฟิสิกส์ผมเคยบอกเพื่อนภาคคณิตศาสตร์ว่าผมไม่จะแตะทฤษฎีจำนวนอีกแล้วแต่การคำนวณควอนตัมทำให้ผมต้องผิดคำพูด  (แต่เดี๋ยวก็จะเห็นว่ามันเป็นทฤษฎีกรุ๊ปที่ผมชอบซะส่วนใหญ่)
<center>
**ทำลายระบบ RSA ≤ หา totient function ≤ แยกตัวประกอบ ≤ หารากที่สองที่ไม่ชัดของ 1 ≤ หาคาบ**
</center>

## ทำลายระบบ RSA ด้วยการแยกตัวประกอบ

ใน[โพสท์ที่แล้ว](https://ninnat.github.io/quantum-algorithms.html)ผมอธิบายการทำงานของรหัส RSA ไว้อย่างคร่าวๆ แต่ไม่ได้ใช้สมการ ให้ m เป็นข้อความ (message), e เป็นกุญแจเข้ารหัสลับ (encryption key), และ  d เป็นกุญแจถอดรหัส (decryption key) ระบบ RSA เข้ารหัสด้วยการเลือกจำนวนเต็ม N และคำนวณ m ยกกำลัง e ในเลขคณิตนาฬิกา mod N
$$ f(m) \equiv m^e \mod N $$
ส่วนการถอดรหัสทำโดยยกกำลังอีกครั้งจนได้ข้อความเดิมกลับมา
$$ (m^e)^d = m^{ed} \equiv m \mod N $$
ในการเข้ารหัสด้วย[กุญแจสาธารณะ](https://ninnat.github.io/quantum-algorithms.html) (public key cryptography) ทุกๆคนมีสิทธิ์ที่จะรู้ e และ N แต่ผู้รับสาส์นเท่านั้นที่จะมีกุญแจถอดรหัส d เตรียมอยู่แล้ว ดังนั้นคำถามของนักแฮกก็คือเราจะคำนวณ d จาก e และ N ได้อย่างไร?

ถ้าไม่คิดอะไร เราอาจจะนึกว่า $ed \equiv 1 \mod N$ คือคำตอบ แต่ $a^{b \mod N} \not\equiv a^b \mod N$ [^1] แต่ปรากฏว่าถ้าเราแยกตัวประกอบได้ เราก็หาค่า M ที่ทำให้
$$ ed \equiv 1 \mod M $$
ได้ ยกตัวอย่างเช่น เมื่อ N เป็นผลคูณของจำนวนเฉพาะแค่สองจำนวน N=pq ค่าของ M คือ (p-1)(q-1) แล้วเราก็หาอินเวอร์สการคูณของ e ใน mod M ด้วย[อัลกอริธึมของยูคลิด](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Computing_multiplicative_inverses_in_modular_structures) ปัญหาการทำลายระบบ RSA จึงสามารถลดรูปเป็นปัญหาการแยกตัวประกอบได้

[^1]: เช่น $2^5 \equiv 2^{1 \mod 4}$ แต่ $2^5 = 32 \equiv 0 \mod 4$
<!-- Cristopher Moore และ Stephan Mertens, *The Nature of Computation*-->
