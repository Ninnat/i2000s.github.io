---
layout: post
title: อัลกอริธึมของชอร์
subtitle: ส่วนที่เป็นคลาสสิคัล, ส่วนที่เป็นควอนตัม, ข้อควรระวัง, และรหัสลับหลังควอนตัม (post-quantum)
date: 2018-11-03
categories:
  - Quantum Information
tags:

---

อัลกอริธึมแยกตัวประกอบเป็นแอปปลิเคชันของคอมพิวเตอร์ควอนตัมที่สำคัญที่สุดหรือเปล่า? ผมว่าไม่ ผมคิดว่าการจำลองระบบควอนตัมจะเป็นแอปปลิเคชันที่ส่งผลกระทบต่อวิทยาศาสตร์และสังคมมากที่สุด แต่การทำลายระบบความปลอดภัย RSA เป็นเรื่องที่ถูกถามบ่อยที่สุดก็เลยอยากจะเขียนเอาไว้อ้างถึง (มี[บล็อก](https://khunpanya.wordpress.com/2016/07/31/shors-algorithm/)ของคุณปัญญาอีกบล็อกที่เขียนเรื่องอัลกอริธึมนี้)

ก่อนอื่นเลย อัลกอริธึมแยกตัวประกอบของชอร์เป็นอัลกอริธึมหาคาบ (period finding) ของฟังก์ชันประเภทหนึ่ง ดังนั้นเราต้องมาเข้าใจกันก่อนว่าปัญหาการทำลายระบบ RSA และการแยกตัวประกอบลดรูปไปเป็นการหาคาบได้อย่างไร ซึ่งความเข้าใจส่วนนี้ไม่เกี่ยวกับควอนตัมเลย เป็นทฤษฎีจำนวนล้วนๆ [^1] ในส่วนแรกของโพสท์นี้เราจะลดรูปปัญหาเป็นขั้นๆดังนี้
<p>
<center>
ทำลายระบบ RSA ≤ หา totient function ≤ แยกตัวประกอบ ≤ หารากที่สองที่ไม่ชัดของ 1 ≤ หาคาบ
</center>
</p>

โดย A ≤ B หมายความคร่าวๆว่าถ้าแก้ปัญหา B ได้ก็แก้ A ได้ใน polynomial time

## ทำลายระบบ RSA ด้วยการแยกตัวประกอบ

ใน[โพสท์ที่แล้ว](https://ninnat.github.io/quantum-algorithms.html)ผมอธิบายการทำงานของรหัส RSA ไว้อย่างคร่าวๆ แต่ไม่ได้ใช้สมการ ให้ $m$ เป็นข้อความ (message), $e$ เป็นกุญแจเข้ารหัสลับ (encryption key), และ  $d$ เป็นกุญแจถอดรหัส (decryption key) ระบบ RSA เข้ารหัสด้วยการเลือกจำนวนเต็ม $N$ และคำนวณ $m$ ยกกำลัง $e$ ในเลขคณิตนาฬิกา
$$ f(m) \equiv m^e \mod N $$
ส่วนการถอดรหัสทำโดยยกกำลังอีกครั้งจนได้ข้อความเดิมกลับมา
$$ (m^e)^d = m^{ed} \equiv m \mod N $$
ในการเข้ารหัสด้วย[กุญแจสาธารณะ](https://ninnat.github.io/quantum-algorithms.html) (public key cryptography) ทุกๆคนมีสิทธิ์ที่จะรู้ $e$ และ $N$ แต่ผู้รับสาส์นเท่านั้นที่จะมีกุญแจถอดรหัส $d$ เตรียมอยู่แล้ว ดังนั้นคำถามของนักแฮกก็คือเราจะคำนวณ $d$ จาก $e$ และ $N$ ได้อย่างไร? [^3]

ปรากฏว่าถ้าเราแยกตัวประกอบได้ เราก็หาค่า $M$ ที่ทำให้
$$ ed \equiv 1 \mod M $$
ได้ ยกตัวอย่างเช่น เมื่อ $N$ เป็นผลคูณของจำนวนเฉพาะแค่สองจำนวน $N=pq$ ค่าของ $M$ คือ $(p-1)(q-1)$ แล้วเราก็หาอินเวอร์สการคูณของ $e$ ใน mod $M$ ด้วย[อัลกอริธึมของยูคลิด](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Computing_multiplicative_inverses_in_modular_structures) ได้ $d$ ออกมา ปัญหาการทำลายระบบ RSA จึงสามารถลดรูปเป็นปัญหาการแยกตัวประกอบได้

ถ้าต้องการหาค่า $M$ โดยทั่วไป มันคือ [totient function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)
$\varphi(N)$ ของออยเลอร์ (Euler) ซึ่งผมแอบรายละเอียดเอาไว้ด้านล่าง สามารถคลิกลูกศรเพื่อเปิดดูได้

---

<details><summary>**การหาค่าของ $M$: $N$ เป็นจำนวนเฉพาะ**</summary>

<p>

การคำนวณ totient function เป็น generalization ของ[ทฤษฎีบทน้อยๆของแฟร์มา](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) (Fermat's little theorem): เมื่อ $p$ เป็นจำนวนเฉพาะและ $a$ กับ $p$ เป็น coprime (ห.ร.ม.=1)
$$ a^{p-1} \equiv 1 \mod p $$
ทฤษฎีบทนี้[พิสูจน์](https://en.wikipedia.org/wiki/Proofs_of_Fermat%27s_little_theorem) ได้ด้วยทฤษฎีกรุ๊ป จำนวนใน $\mathbb{Z}_p$  ที่มีอินเวอร์การคูณประกอบกันเป็น cyclic group $\mathbb{Z}_p^*$ ซึ่งมีขนาด $p-1$  (เพราะจำนวนทุกจำนวนที่เป็น coprime กับ $p$ เป็น generators ของกรุ๊ปหมด เหลือแค่ $p$ ตัวเดียวที่ไม่มีอินเวิร์ส) $a^{p-1}$ จึงเท่ากับ 1 mod $p$ ด้วย[ทฤษฎีบทของลากรานจ์](https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)) เพราะกรุ๊ปที่ generated โดย $a$ เป็นซับกรุ๊ป (subgroup) ของ $\mathbb{Z}_p^*$
</p>
</details>

<details><summary>**การหาค่าของ $M$: $N$ เป็นกำลังของจำนวนเฉพาะ**</summary>

<p>

เมื่อ $N$ เป็นกำลังของจำนวนเฉพาะ (prime power) $N = p^r$, จำนวนที่ไม่เป็น coprime กับ $p^r$ ใน $\mathbb{Z}_{p^r}$ และไม่มากกว่า $p^r$ คือ $p,2p,\cdots,p^{r-1}p$ ซึ่งมี $p^{r-1}$ จำนวน ดังนั้น $\varphi(N) = p^r - p^{r-1}$
</p>
</details>

<details><summary>**การหาค่าของ $M$: $N$ ทั่วไป**</summary>

<p>

เมื่อ $N$ เป็นผลคูณของกำลังของจำนวนเฉพาะ $N = p_1^{r_1} p_2^{r_2}$ เราสามารถ[พิสูจน์](https://en.wikipedia.org/wiki/Euler%27s_totient_function#Computing_Euler%27s_totient_function)ได้ว่า totient function  เป็นผลคูณ $\varphi(p_1^{r_1}) \varphi(p_2^{r_2})$ หรือ
$$ \varphi(p_1^{r_1}p_2^{r_2} \cdots p_k^{r_k}) = (p_1^{r_1}-p_1^{r_1-1}) (p_2^{r_2}-p_2^{r_2-1}) \cdots (p_k^{r_k}-p_k^{r_k-1}) $$
นั่นเอง ทำให้ได้ว่า
$$ \varphi(N) = (p-1)(q-1) $$
เมื่อ $N$ เป็นผลคูณของจำนวนเฉพาะสองจำนวน
</p>
</details>

---

การที่ RSA รักษาความปลอดภัยได้ก็เพราะไม่มีใครมีอัลกอริธึมคลาสสิคัลที่แยกตัวประกอบได้อย่างรวดเร็ว วิธีหนึ่งในการหาตัวประกอบของ $N$ คือไล่หาร $N$ ด้วยจำนวนเล็กๆไปเรื่อยๆจนกว่าจะเจอตัวหาร ซึ่งอาจจะต้องหารไปถึง $\sqrt{N}$ ตัว ทำไมนี่ไม่ใช่อัลกอริธึม polynomial-time ล่ะ? เหตุผลก็คือเราต้องการแค่ $\log N$ บิตในการบันทึกจำนวนเต็ม $N$ ขนาดของอินพุตจึงไม่ใช่ $N$ แต่เป็น $n=\log N$ ต่างหาก อัลกอริธึมไล่หารโง่ๆจึงใช้เวลา $2^{n/2}$ อัลกอริธึมคลาสสิคัลที่ดีสุด (Number Field Sieve) ก็ยัง[ใช้เวลา](http://math.mit.edu/~cohn/Thoughts/factoring.html)ประมาณ $2^{n^{1/3}}$ ยังเป็นทวีคูณ (exponential) ในขนาดของอินพุต

## แยกตัวประกอบด้วยการหาคาบ

สิ่งที่นักวิทยาศาสตร์คอมพิวเตอร์รู้มาก่อนชอร์ก็คือถ้าเราสุ่มเอาจำนวน $a$ มาหาคาบใน $\text{mod}\,N$ เยอะๆ เราก็จะหาตัวประกอบของ $N$ ได้ [^4] คาบของ $a$ คือจำนวน $r$ ที่น้อยที่สุดที่
$$ x^r \equiv 1 \mod N $$
โดยถ้า $N$ มี $k$ ตัวประกอบ โอกาสที่จะสุ่มได้ $a$ ที่ให้ตัวประกอบเมื่อนำมาหาคาบคือ $1-1/2^{k-1}$ คือยังไงก็มีโอกาสไม่น้อยกว่าครึ่ง

ไอเดียก็คือถ้า $r$ หารด้วย 2 ลงตัว $a^{r/2}$ ก็จะเป็นรากที่สองของ 1 ใน $\text{mod}\,N$ แล้วรากที่สองเอาไปทำอะไรได้? ไอเดียที่เหลือมาจาก[การทดสอบจำนวนเฉพาะ ของมิลเลอร์และราบิน](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test) (Miller-Rabin primality testing): รากที่สองของ 1
$$ b^2 \equiv 1 \mod N $$
มีแน่ๆอยู่แล้วสองตัวคือ 1 และ $-1 \equiv N-1\,\,\text{mod}\,N$ เรียกว่ารากที่สองที่ชัด (trivial) แต่ถ้าเมื่อไรมีรากที่สองมากไปกว่านี้ (nontrivial square root)
$N$ จะต้องเป็นจำนวนประกอบเพราะหาก $b \not\equiv \pm 1\,\,\text{mod}\,N$ และ
$$ b^2 -1 = (b+1)(b-1) \equiv 0 \mod N $$
$N$ จะต้องหาร $(b+1)(b-1)$ ลงตัว แต่ $N$ หาร $b+1$ หรือ $b-1$ โดดๆไม่ลงตัว (เพราะ $b \pm 1 \not\equiv 0\,\,\text{mod}\,N$) $N$ จึงต้องเป็นผลคูณของตัวประกอบที่แบ่งไปหาร $b+1$ กับ $b-1$ แยกกัน ด้วยเหตุนี้ ห.ร.ม.ของ $b \pm 1$ และ $N$ จึงเป็นตัวประกอบของ $N$

---

<details><summary>**ความน่าจะเป็นที่จะได้ $a$ ที่ต้องการ**</summary>
<p>

ยังไม่ได้เขียน
</p>
</details>

---

## หาคาบด้วยอัลกอริธึมควอนตัม

# ข้อควรระวังในการรันอัลกอริธึม

"Compiled Shor's algorithm"

# ความซับซ้อนของการแยกตัวประกอบ

Factoring อยู่ใน NP ∩ coNP เชื่อว่าไม่ NP-complete มิฉะนั้น PH จะยุบมาถึงระดับที่หนึ่ง (NP=coNP=PH)

[^1]: ตอนก่อนจะมาเรียนฟิสิกส์ผมเคยบอกเพื่อนภาคคณิตศาสตร์ว่าผมไม่จะแตะทฤษฎีจำนวนอีกแล้วแต่การคำนวณควอนตัมทำให้ผมต้องผิดคำพูด  (แต่เดี๋ยวก็จะเห็นว่ามันเป็นทฤษฎีกรุ๊ปที่ผมชอบซะส่วนใหญ่)

[^3]: ถ้าไม่คิดอะไร เราอาจจะนึกว่า $ed \equiv 1 \mod N$ คือคำตอบ แต่ $a^{b \mod N} \not\equiv a^b \mod N$ เช่น $2^5 \equiv 2^{1 \mod 4}$ แต่ $2^5 = 32 \equiv 0 \mod 4$

[^4]: หรือถ้าเช็คได้ว่า $a$ เป็นจำนวนเฉพาะ ([ซึ่งทำได้ใน polynomial time](https://en.wikipedia.org/wiki/Primality_test)) และโชคดี ห.ร.ม. ของ $a$ กับ $N$ ไม่ใช่ 1 ก็จบ ห.ร.ม.นั่นแหละคือตัวประกอบ
<!-- Cristopher Moore และ Stephan Mertens, *The Nature of Computation*-->
